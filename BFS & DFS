Number of possible edges = n(n-1)/2
Total undirected graphs = 2^(n(n-1)/2)

Connected Components
# Step 1: Build adjacency list
    adj = defaultdict(list)
    for u, v in edges:
        adj[u].append(v)
        adj[v].append(u)

DFS iteravtive
def connectedComponents(V, edges):
    from collections import defaultdict

    visited = [False] * V
    result = []

    # Step 2: Iterative DFS using stack
    for start in range(V):
        if not visited[start]:
            stack = [start]
            component = []

            while stack:
                node = stack.pop()
                if not visited[node]:
                    visited[node] = True
                    component.append(node)
                    # Push all unvisited neighbors onto the stack
                    for neighbor in adj[node]: #if order matters use reversed
                        if not visited[neighbor]:
                            stack.append(neighbor)

            result.append(sorted(component))  # Sort each component if needed

    return result
DFS recursive
def connectedComponents(V, edges):
    from collections import defaultdict

    visited = [False] * V
    result = []

    def dfs(node, component):
        visited[node] = True
        component.append(node)
        for neighbor in adj[node]:
            if not visited[neighbor]:
                dfs(neighbor, component)

    # Step 2: Visit each vertex
    for v in range(V):
        if not visited[v]:
            component = []
            dfs(v, component)
            result.append(sorted(component))  # Sorting each component

    return result
BFS 
from collections import defaultdict, deque

def connectedComponents(V, edges):

    visited = [False] * V
    result = []

    # Step 2: BFS for each unvisited node
    for start in range(V):
        if not visited[start]:
            queue = deque([start])
            component = []

            while queue:
                node = queue.popleft()
                if not visited[node]:
                    visited[node] = True
                    component.append(node)

                    for neighbor in adj[node]:
                        if not visited[neighbor]:
                            queue.append(neighbor)

            result.append(sorted(component))  # Sort component if needed

    return result

Connected components(DFS)
class Solution:
    def findCircleNum(self, grid: List[List[int]]) -> int:
        if not grid: 
            return 0
        count = 0
        n = len(grid) 
        visited = [0] * n
        stack = []
        for i in range(n): 
            if (not visited[i]):
                stack.append(i)
                count += 1
                #DFS
                while stack:
                    node = stack.pop()
                    for neighbour in range(n):
                        if not visited[neighbour] and grid[node][neighbour] == 1:
                            visited[neighbour] = True
                            stack.append(neighbour)
        return count

completene components
def countCompleteComponents(n, edges):
    # Build the adjacency list and an adjacency matrix for easy lookup
    adj_list = [[] for _ in range(n)]
    adj_matrix = [[False for _ in range(n)] for _ in range(n)]
    
    for a, b in edges:
        adj_list[a].append(b)
        adj_list[b].append(a)
        adj_matrix[a][b] = True
        adj_matrix[b][a] = True
    
    visited = [False] * n
    complete_count = 0
    
    def dfs(node, component):
        stack = [node]
        visited[node] = True
        component.append(node)
        while stack:
            current = stack.pop()
            for neighbor in adj_list[current]:
                if not visited[neighbor]:
                    visited[neighbor] = True
                    component.append(neighbor)
                    stack.append(neighbor)
        return component
    
    for i in range(n):
        if not visited[i]:
            component = dfs(i, [])
            # Check if the component is complete
            k = len(component)
            is_complete = True
            for a in range(k):
                for b in range(a + 1, k):
                    u = component[a]
                    v = component[b]
                    if not adj_matrix[u][v]:
                        is_complete = False
                        break
                if not is_complete:
                    break
            if is_complete:
                complete_count += 1
    return complete_count

What is Union-Find?
Union-Find has two main operations:

Union(x, y): Merges the groups containing elements x and y into a single group.
Find(x): Determines the "representative" (or root) of the group that x belongs to.
By tracking these groups, we can count how many separate clusters (provinces) exist at the end.

Key Components
Parent Array: Each element (city) has a parent pointer. Initially, every city is its own parent (a group of one).
Find with Path Compression: When finding a city’s root, we optimize by making all nodes in the path point directly to the root.
Union: Merges two groups by setting the root of one group to point to the root of the other.

class Solution:
    def findCircleNum(self, isConnected):
        n = len(isConnected)
        parent = list(range(n))  # Initial parent array
        def find(x):
            if parent[x] != x:
                parent[x] = find(parent[x])  # Path compression
            return parent[x]
        def union(x, y):
            parent[find(x)] = find(y)
        # Process connections
        for i in range(n):
            for j in range(i + 1, n):  # Avoid duplicates due to symmetry
                if isConnected[i][j] == 1:
                    union(i, j)
        # Count distinct roots
        provinces = len(set(find(i) for i in range(n)))
        return provinces

increment after for
Rotten Oranges 
from collections import deque
from typing import List

class Solution:
    def orangesRotting(self, grid: List[List[int]]) -> int:
        if not grid:
            return 0
        m = len(grid)
        n = len(grid[0])
        Q = deque()
        fresh = 0

        # since we dk starting point
        for i in range(m):
            for j in range(n):
                if grid[i][j] == 2:
                    Q.append((i,j))
                elif grid[i][j] == 1:
                    fresh += 1

        if fresh == 0:
            return 0

        directions = [(-1,0),(0,1),(1,0),(0,-1)]
        minutes = 0
        
        while Q and fresh>0:
            for _ in range(len(Q)):
                r , c = Q.popleft()
                for dr ,dc in directions:
                    nr = r + dr
                    nc = c + dc
                    if 0 <= nr < m and 0 <= nc < n and grid[nr][nc] == 1:
                        grid[nr][nc] = 2
                        fresh -= 1
                        Q.append((nr,nc))
                
            minutes +=1
        return minutes if fresh == 0 else -1

Surrounded Regions
Key insight
Edge 'O's cannot be captured because they're not fully surrounded by 'X's.
Any 'O' connected (directly/indirectly) to an edge 'O' also cannot be captured.
Only 'O's completely enclosed by 'X's (with no connection to edges) should be flipped.
Approach 
Mark Edge 'O's and Their Connections:
Use BFS (queue) to propagate from edge 'O's to all connected 'O's.
Mark them as 'T' to indicate they're safe from flipping.
Process the Queue:
For each 'O' in the queue, check its 4-directional neighbors.
If neighbor is 'O', mark it as 'T' and add to queue (to continue BFS).
Final Flip & Restore:
After BFS completes, all remaining 'O's are surrounded → flip them to 'X'.
Restore 'T's to 'O's.

from collections import deque

def solve(board):
    if not board:
        return
    
    m, n = len(board), len(board[0])
    queue = deque()

    # Step 1: Mark edge 'O's and their connected 'O's as 'T' (BFS)
    for i in range(m):
        for j in range(n):
            if (i == 0 or i == m-1 or j == 0 or j == n-1) and board[i][j] == 'O':
                queue.append((i, j))
                board[i][j] = 'T'
                while queue:
                    r, c = queue.popleft()
                    for dr, dc in [(-1,0), (1,0), (0,-1), (0,1)]:
                        nr, nc = r + dr, c + dc
                        if 0 <= nr < m and 0 <= nc < n and board[nr][nc] == 'O':
                            board[nr][nc] = 'T'
                            queue.append((nr, nc))

    # Step 2: Flip remaining 'O's to 'X' and restore 'T's to 'O's
    for i in range(m):
        for j in range(n):
            if board[i][j] == 'O':
                board[i][j] = 'X'
            elif board[i][j] == 'T':
                board[i][j] = 'O'
DFS
def solve(board):
    if not board:
        return
    
    m, n = len(board), len(board[0])

    def dfs(i, j):
        if 0 <= i < m and 0 <= j < n and board[i][j] == 'O':
            board[i][j] = 'T'
            dfs(i+1, j)
            dfs(i-1, j)
            dfs(i, j+1)
            dfs(i, j-1)

    # Step 1: Mark edge 'O's and their connected 'O's as 'T' (DFS)
    for i in range(m):
        for j in range(n):
            if (i == 0 or i == m-1 or j == 0 or j == n-1) and board[i][j] == 'O':
                dfs(i, j)

    # Step 2: Flip remaining 'O's to 'X' and restore 'T's to 'O's
    for i in range(m):
        for j in range(n):
            if board[i][j] == 'O':
                board[i][j] = 'X'
            elif board[i][j] == 'T':
                board[i][j] = 'O'
WORD LADDER
def ladderLength(beginWord, endWord, wordList):
    wordSet = set(wordList)
    if endWord not in wordSet:
        return 0
    if beginWord in wordSet:
        wordSet.remove(beginWord)
    
    queue = deque([(beginWord, 1)])
    
    while queue:
        word, length = queue.popleft()
        if word == endWord:
            return length
        
        for i in range(len(word)):
            for c in 'abcdefghijklmnopqrstuvwxyz':
                next_word = word[:i] + c + word[i+1:]
                if next_word in wordSet:
                    wordSet.remove(next_word)
                    queue.append((next_word, length + 1))
    
    return 0

Bipartite!
def isBipartite(self, graph: List[List[int]]) -> bool:
        V = len(graph)
        visited = [False]*V
        color = [-1]*V

        def dfs(i):
            st=[i]
            color[i] = 0
            while st:
                node = st.pop()
                for neighbour in graph[node]:
                    if color[neighbour] == -1:
                        color[neighbour] = 1 - color[node]
                        st.append(neighbour) 
                    elif color[neighbour] == color[node]:
                        return False
            return True 

        for i in range(V):
            if color[i] == -1:
                if not dfs(i):
                    return False
        return True

CLONE GRAPH
def cloneGraph(node):
    visited = {}
    def dfs(n):
        if n in visited:
            return visited[n]
        copy = Node(n.val)
        visited[n] = copy
        for neighbor in n.neighbors:
            copy.neighbors.append(dfs(neighbor))
        return copy
    return dfs(node) if node else None

from collections import deque
def cloneGraph(node):
    if not node:
        return None
    visited = {node: Node(node.val)}
    queue = deque([node])
    while queue:
        current = queue.popleft()
        for neighbor in current.neighbors:
            if neighbor not in visited:
                visited[neighbor] = Node(neighbor.val)
                queue.append(neighbor)
            visited[current].neighbors.append(visited[neighbor])
    return visited[node]










                
        
        


