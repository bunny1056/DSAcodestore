class Solution:
    memo = {}
    def fib(self, n: int) -> int:
        if n in self.memo:
            return self.memo[n]
        if n <= 1:
            return n
        self.memo[n] = self.fib(n-2) + self.fib(n-1)
        return self.memo[n]

Subsets
def isSubsetSum(arr, n, sum):
    dp = [[False] * (sum + 1) for _ in range(n + 1)]

    for i in range(n + 1):
        dp[i][0] = True

    for i in range(1, n + 1):
        for j in range(1, sum + 1):
            if arr[i - 1] > j:
                dp[i][j] = dp[i - 1][j]
            else:
                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - arr[i - 1]]

    return dp[n][sum]

What is dp[i - 1][j - arr[i - 1]]?
The DP table dp[i][j] answers: "Can we make sum j using the first i elements of the array?"
When we consider the i-th element (which is arr[i - 1] because the array is 0-indexed), we have two choices:
Exclude it: Check if we can make sum j without it, i.e., dp[i - 1][j].
Include it: If we use arr[i - 1], it contributes arr[i - 1] to the sum. To reach the target j, we need the remaining sum j - arr[i - 1] to be achievable using the first i - 1 elements.
dp[i - 1][j - arr[i - 1]] is a boolean that tells us whether it’s possible to form the sum j - arr[i - 1] using only the first i - 1 elements (i.e., excluding the current element).
If dp[i - 1][j - arr[i - 1]] is True, it means we can make j - arr[i - 1] with some subset of the first i - 1 elements. By adding arr[i - 1] to that subset, we can achieve the total sum j.

def perfect_sum(arr, target):
    n = len(arr)
    
    # Create a DP table where dp[i][j] is the number of subsets from the first i elements that sum to j
    dp = [[0] * (target + 1) for _ in range(n + 1)]

    # There's one subset (the empty subset) that sums to 0
    for i in range(n + 1):
        dp[i][0] = 1

    # Fill the DP table
    for i in range(1, n + 1):
        for j in range(target + 1): ## 0 is valid (in coin change qn also)
            if arr[i - 1] <= j:
                dp[i][j] = dp[i - 1][j] + dp[i - 1][j - arr[i - 1]]
            else:
                dp[i][j] = dp[i - 1][j]

    return dp[n][target]

logic :target sum or given difference
target = (d + sum(arr))//2
        total_sum = sum(arr)
        if (d + total_sum) % 2 != 0 or (d + total_sum) < 0:
            return 0
req = (sum(nums)+target) // 2
        if (sum(nums)+target) % 2 == 1 or sum(nums) < abs(target):
            return 0

Coin change I
def coinChange(self, coins: List[int], amount: int) -> int:
    max_val = amount + 1  # A placeholder for "infinity" (no. of coins can’t exceed amount)
    dp = [max_val] * (amount + 1)
    dp[0] = 0  # Base case: 0 coins to make amount 0

    for coin in coins:
        for x in range(coin, amount + 1):
            dp[x] = min(dp[x], dp[x - coin] + 1)

    return dp[amount] if dp[amount] != max_val else -1
Coin change II
def change(self, amount: int, coins: List[int]) -> int:
        res = [0] * (amount + 1)
        res[0] = 1
        
        for c in coins:
            for a in range(c, amount + 1):
                res[a] += res[a - c]

def knapSack(self, val, wt,capacity):
        # code here
        dp = [0]* (capacity+1)
        for i in range(1, capacity + 1):
            for j in range(len(val)):
                if wt[j] <= i:
                    dp[i] = max(dp[i],dp[i-wt[j]]+val[j])
        return dp[capacity]      
        return res[amount]
Rod cutting
def cutRod(price):
    n = len(price)
    dp = [0] * (n + 1)

    # Find maximum value for all 
    # rod of length i.
    for i in range(1, n + 1):
        for j in range(1, i + 1):
            dp[i] = max(dp[i], price[j - 1] + dp[i - j])

    return dp[n]
