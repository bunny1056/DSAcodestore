def RLroottraversal(t):
  if t != None:
    traversal(t.right)
    traversal(t.left)
    print(t.value, end = '')
traversal(root)

Pre-order
def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        result = []
        
        def helper(root):
            if root == None:
                return 
            result.append(root.val)

            helper(root.left)
            helper(root.right)
        helper(root)

        return result

Level order traversal
def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        if not root:
            return []

        Q = deque()
        Q.append(root)
        
        result = []

        while Q:
            level_size = len(Q)
            current_level = []

            for _ in range(level_size):
                node = Q.popleft()
                current_level.append(node.val)
                if node.left:
                    Q.append(node.left)
                if node.right:
                    Q.append(node.right)
            result.append(current_level)
        return result
using stack
class Solution:
    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        if not root:
            return []
        stack, result = [root], []
        while stack:
            node = stack.pop()
            result.append(node.val)
            if node.right:
                stack.append(node.right)
            if node.left:
                stack.append(node.left)
        return result

height
def maxDepth(self, root: Optional[TreeNode]) -> int:
        if root is None:
            return 0
        left_height = self.maxDepth(root.left)
        right_height = self.maxDepth(root.right)
        return 1 + max(left_height, right_height)

balanced BT
def isBalanced(self, root: Optional[TreeNode]) -> bool:
        def check(node):
            if not node:
                return 0
            left_height = check(node.left)
            if left_height == -1:
                return -1
            right_height = check(node.right)
            if right_height == -1:
                return -1
            if abs(left_height - right_height) > 1:
                return -1
            return 1 + max(left_height,right_height)
        return check(root) != -1

def maxPathSum(self, root: Optional[TreeNode]) -> int:
        ans = float('-inf')
        def cal(node):
            nonlocal ans
            if not node:
                return 0
            left_sum = max(cal(node.left),0)
            right_sum = max(cal(node.right),0)

            price_newpath = node.val + left_sum + right_sum
            ans = max(ans,price_newpath)
                
            return node.val + max(left_sum,right_sum)
        cal(root)
        return ans
