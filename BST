The key observation here is that in a BST, an in-order traversal yields the nodes in ascending order.
def searchBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:
    def helper(node, val):
        if not node:
            return None  # Base case: value not found
        if node.val == val:
            return node  # Base case: value found
        if val < node.val:
            return helper(node.left, val)  # Propagate result from left subtree
        else:
            return helper(node.right, val)  # Propagate result from right subtree
    
    return helper(root, val)  # Initiate search and return result

    def getMinimumDifference(self, root: Optional[TreeNode]) -> int:
        def inorder(node):
            if not node:
                return []
            return inorder(node.left) + [node.val] + inorder(node.right)
        
        values = inorder(root)
        min_diff = float('inf')
        for i in range(1, len(values)):
            diff = values[i] - values[i-1]
            if diff < min_diff:
                min_diff = diff
        return min_diff

Floor/Ceil in BST
        key = x
        floor = -1
        while root:
            if root.data == key:
                return root.data
            elif root.data < key:
                floor = root.data  # Update floor
                root = root.right  # Search right for a larger floor
            else:
                root = root.left  # Search left for a smaller value
        return floor

delete a Node
if not root:
            return root
        
        if key < root.val:
            root.left = self.deleteNode(root.left, key)
        elif key > root.val:
            root.right = self.deleteNode(root.right, key)
        else:
            # Node with only one child or no child
            if not root.left:
                return root.right
            elif not root.right:
                return root.left
            
            # Node with two children: Get the inorder successor (smallest in the right subtree)
            if root.right:
                temp = self.findMin(root.right)
                root.val = temp.val
                root.right = self.deleteNode(root.right, temp.val)
            else:
                # If right subtree is empty, get the inorder predecessor (largest in the left subtree)
                temp = self.findMax(root.left)
                root.val = temp.val
                root.left = self.deleteNode(root.left, temp.val)
        
        return root
    
    def findMin(self, node):
        current = node
        while current.left:
            current = current.left
        return current
    
    def findMax(self, node):
        current = node
        while current.right:
            current = current.right
        return current

def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:
    count = 0
    def dfs(node: Optional[TreeNode]) -> int:
        if not node:
            return None

        value = dfs(node.left)
        if value is not None:
            return value

        nonlocal count
        count += 1
        if count == k:
            return node.val

        value = dfs(node.right)
        if value is not None:
            return value

        return None
    return dfs(root)

valid BST

class Solution:
    def isValidBST(self, root: Optional[TreeNode]) -> bool:
        stack = []
        prev = None
        
        while stack or root:
            while root:
                stack.append(root)
                root = root.left
            root = stack.pop()
            if prev is not None and root.val <= prev.val:
                return False
            prev = root
            root = root.right
        return True

How the Code Works
Start at the Root:
Begin traversing from the root of the BST.
Compare Values:
If both p and q are greater than the current node's value, their LCA must be in the right subtree.
If both p and q are smaller than the current node's value, their LCA must be in the left subtree.
If neither condition is met, the current node is the LCA because:
One of p or q is equal to the current node (ancestor of itself), or
p and q are in different subtrees (so the current node is their last common ancestor).
Termination:
The loop exits when the current node is the LCA, which is then returned.

def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        while root:
            if p.val > root.val and q.val > root.val:
                root = root.right
            elif p.val < root.val and q.val < root.val:
                root = root.left
            else:
                return root
