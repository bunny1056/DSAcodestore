def RLroottraversal(t):
  if t != None:
    traversal(t.right)
    traversal(t.left)
    print(t.value, end = '')
traversal(root)

Pre-order
def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        result = []
        
        def helper(root):
            if root == None:
                return 
            result.append(root.val)

            helper(root.left)
            helper(root.right)
        helper(root)

        return result

Level order traversal
def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        if not root:
            return []

        Q = deque()
        Q.append(root)
        
        result = []

        while Q:
            level_size = len(Q)
            current_level = []

            for _ in range(level_size):
                node = Q.popleft()
                current_level.append(node.val)
                if node.left:
                    Q.append(node.left)
                if node.right:
                    Q.append(node.right)
            result.append(current_level)
        return result
using stack
class Solution:
    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        if not root:
            return []
        stack, result = [root], []
        while stack:
            node = stack.pop()
            result.append(node.val)
            if node.right:
                stack.append(node.right)
            if node.left:
                stack.append(node.left)
        return result

height
def maxDepth(self, root: Optional[TreeNode]) -> int:
        if root is None:
            return 0
        left_height = self.maxDepth(root.left)
        right_height = self.maxDepth(root.right)
        return 1 + max(left_height, right_height)

balanced BT
def isBalanced(self, root: Optional[TreeNode]) -> bool:
        def check(node):
            if not node:
                return 0
            left_height = check(node.left)
            if left_height == -1:
                return -1
            right_height = check(node.right)
            if right_height == -1:
                return -1
            if abs(left_height - right_height) > 1:
                return -1
            return 1 + max(left_height,right_height)
        return check(root) != -1

def maxPathSum(self, root: Optional[TreeNode]) -> int:
        ans = float('-inf')
        def cal(node):
            nonlocal ans
            if not node:
                return 0
            left_sum = max(cal(node.left),0)
            right_sum = max(cal(node.right),0)

            price_newpath = node.val + left_sum + right_sum
            ans = max(ans,price_newpath)
                
            return node.val + max(left_sum,right_sum)
        cal(root)
        return ans

whether two trees are identical
def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:
        if not p and not q:
            return True
        if (p and not q) or (not p and q):
            return False
        if p.val != q.val:
            return False
        return self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)

zigzag traversal
 if not flag:
                current_level = current_level[::-1]
            result.append(current_level)
            flag = not flag

boundary traversal
def boundaryTraversal(self, root):
    def is_leaf(node):
        return node.left is None and node.right is None

    def left_boundary(node, boundary):
        curr = node.left
        while curr:
            if not is_leaf(curr):
                boundary.append(curr.data)
            if curr.left:
                curr = curr.left
            else:
                curr = curr.right

    def right_boundary(node, boundary):
        curr = node.right
        st = []
        while curr:
            if not is_leaf(curr):
                st.append(curr.data)
            if curr.right:
                curr = curr.right
            else:
                curr = curr.left
        while st:
            boundary.append(st.pop())

    def add_leaves(node, boundary):
        if is_leaf(node):
            boundary.append(node.data)
        else:
            if node.left:
                add_leaves(node.left, boundary)
            if node.right:
                add_leaves(node.right, boundary)

    if not root:
        return []

    boundary = []
    if not is_leaf(root):  # Fix here
        boundary.append(root.data)

    left_boundary(root, boundary)
    add_leaves(root, boundary)
    right_boundary(root, boundary)

    return boundary

vertical traversal
from collections import defaultdict, deque

def verticalTraversal(root):
    node_list = []

    # BFS traversal
    queue = deque([(root, 0, 0)])  # (node, row, col)

    while queue:
        node, row, col = queue.popleft()
        if node:
            node_list.append((col, row, node.val))
            queue.append((node.left, row + 1, col - 1))
            queue.append((node.right, row + 1, col + 1))

    # Sort by col, then row, then value
    node_list.sort()

    # Grouping by column
    res = defaultdict(list)
    for col, row, value in node_list:
        res[col].append(value)

    # Extract the result columns in order
    return [res[x] for x in sorted(res)]
