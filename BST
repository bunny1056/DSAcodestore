def RLroottraversal(t):
  if t != None:
    traversal(t.right)
    traversal(t.left)
    print(t.value, end = '')
traversal(root)

Pre-order
def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        result = []
        
        def helper(root):
            if root == None:
                return 
            result.append(root.val)

            helper(root.left)
            helper(root.right)
        helper(root)

        return result

Level order traversal
def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        if not root:
            return []

        Q = deque()
        Q.append(root)
        
        result = []

        while Q:
            level_size = len(Q)
            current_level = []

            for _ in range(level_size):
                node = Q.popleft()
                current_level.append(node.val)
                if node.left:
                    Q.append(node.left)
                if node.right:
                    Q.append(node.right)
            result.append(current_level)
        return result
using stack
class Solution:
    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        if not root:
            return []
        stack, result = [root], []
        while stack:
            node = stack.pop()
            result.append(node.val)
            if node.right:
                stack.append(node.right)
            if node.left:
                stack.append(node.left)
        return result

height
def maxDepth(self, root: Optional[TreeNode]) -> int:
        if root is None:
            return 0
        left_height = self.maxDepth(root.left)
        right_height = self.maxDepth(root.right)
        return 1 + max(left_height, right_height)

balanced BT
def isBalanced(self, root: Optional[TreeNode]) -> bool:
        def check(node):
            if not node:
                return 0
            left_height = check(node.left)
            if left_height == -1:
                return -1
            right_height = check(node.right)
            if right_height == -1:
                return -1
            if abs(left_height - right_height) > 1:
                return -1
            return 1 + max(left_height,right_height)
        return check(root) != -1

def maxPathSum(self, root: Optional[TreeNode]) -> int:
        ans = float('-inf')
        def cal(node):
            nonlocal ans
            if not node:
                return 0
            left_sum = max(cal(node.left),0)
            right_sum = max(cal(node.right),0)

            price_newpath = node.val + left_sum + right_sum
            ans = max(ans,price_newpath)
                
            return node.val + max(left_sum,right_sum)
        cal(root)
        return ans

whether two trees are identical
def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:
        if not p and not q:
            return True
        if (p and not q) or (not p and q):
            return False
        if p.val != q.val:
            return False
        return self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)

zigzag traversal
 if not flag:
                current_level = current_level[::-1]
            result.append(current_level)
            flag = not flag

boundary traversal
def boundaryTraversal(self, root):
    def is_leaf(node):
        return node.left is None and node.right is None

    def left_boundary(node, boundary):
        curr = node.left
        while curr:
            if not is_leaf(curr):
                boundary.append(curr.data)
            if curr.left:
                curr = curr.left
            else:
                curr = curr.right

    def right_boundary(node, boundary):
        curr = node.right
        st = []
        while curr:
            if not is_leaf(curr):
                st.append(curr.data)
            if curr.right:
                curr = curr.right
            else:
                curr = curr.left
        while st:
            boundary.append(st.pop())

    def add_leaves(node, boundary):
        if is_leaf(node):
            boundary.append(node.data)
        else:
            if node.left:
                add_leaves(node.left, boundary)
            if node.right:
                add_leaves(node.right, boundary)

    if not root:
        return []

    boundary = []
    if not is_leaf(root):  # Fix here
        boundary.append(root.data)

    left_boundary(root, boundary)
    add_leaves(root, boundary)
    right_boundary(root, boundary)

    return boundary

vertical traversal
from collections import defaultdict, deque

def verticalTraversal(root):
    node_list = []

    # BFS traversal
    queue = deque([(root, 0, 0)])  # (node, row, col)

    while queue:
        node, row, col = queue.popleft()
        if node:
            node_list.append((col, row, node.val))
            queue.append((node.left, row + 1, col - 1))
            queue.append((node.right, row + 1, col + 1))

    # Sort by col, then row, then value
    node_list.sort()

    # Grouping by column
    res = defaultdict(list)
    for col, row, value in node_list:
        res[col].append(value)

    # Extract the result columns in order
    return [res[x] for x in sorted(res)]

views of trees
Topdef topView(root):
    if not root:
        return []

    queue = deque([(root, 0)])  # node, column
    top_nodes = {}

    while queue:
        node, col = queue.popleft()
        if col not in top_nodes:
            top_nodes[col] = node.val
        if node.left:
            queue.append((node.left, col - 1))
        if node.right:
            queue.append((node.right, col + 1))

    return [top_nodes[col] for col in sorted(top_nodes)]

Bottom
def bottomView(root):
    if not root:
        return []

    queue = deque([(root, 0)])
    bottom_nodes = {}

    while queue:
        node, col = queue.popleft()
        bottom_nodes[col] = node.val  # overwrite
        if node.left:
            queue.append((node.left, col - 1))
        if node.right:
            queue.append((node.right, col + 1))

    return [bottom_nodes[col] for col in sorted(bottom_nodes)]

left or right
def leftView(root):
    if not root:
        return []

    result = []
    queue = deque([root])

    while queue:
        level_size = len(queue)
        for i in range(level_size):
            node = queue.popleft()
            if i == 0:  (((( if i == level_size - 1 #for right_view))))
                result.append(node.val)  # first node at this level
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)

    return result

CLSSIC backtracking targetSum Qn
def pathSum(self, root: Optional[TreeNode], targetSum: int) -> List[List[int]]:
        result = []
        def dfs(node,current_path,current_sum):
            if not node:
                return
            current_path.append(node.val)
            current_sum += node.val
            if not node.left and not node.right:
                if current_sum == targetSum:
                    result.append(list(current_path))
            else:
                dfs(node.left,current_path,current_sum)
                dfs(node.right,current_path,current_sum)
            current_path.pop() #backtrack
        dfs(root,[],0)
        return result

lowest common ancestor
### Hint for Finding the Lowest Common Ancestor (LCA) in a Binary Tree

To find the LCA of two nodes `p` and `q` in a binary tree, consider the following approach:

1. **Base Case**: If the current node is `None` or matches either `p` or `q`, return the current node. This is because:
   - If the current node is `None`, it can't be an ancestor.
   - If the current node is `p` or `q`, it might be the LCA (especially if the other node is in its subtree).

2. **Recursive Search**: Recursively search for `p` and `q` in the left and right subtrees of the current node.
   - If both subtrees return non-`None` results, the current node is the LCA because `p` and `q` are found in different subtrees.
   - If only one subtree returns a non-`None` result, that result is the LCA (the other node is in its subtree).
   - If both subtrees return `None`, neither `p` nor `q` exists in the current subtree.

3. **Intuition**: The LCA is the deepest node that has `p` and `q` in its left and right subtrees (or is one of them). The recursion helps propagate this information upwards.

### Key Insight
- The LCA is the first node where `p` and `q` are found in different subtrees (or one is the node itself).
- The recursion naturally explores the tree from the bottom up, making it easy to identify the deepest common ancestor. 

This approach efficiently narrows down the LCA by leveraging the properties of recursion and tree traversal.

def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        if not root:
            return None
        if p==root or q==root:
            return root
        left=self.lowestCommonAncestor(root.left,p,q)
        right=self.lowestCommonAncestor(root.right,p,q)
        if left and right:
            return root
        return left or right

nodes existence
def node_exists(root, node):
            if not root:
                return False
            if root == node:
                return True
            return node_exists(root.left, node) or node_exists(root.right, node)
        
        # Check if both p and q exist in the tree.
        if not node_exists(root, p) or not node_exists(root, q):
            return None

if nodes = 3
r == root and left!= right
