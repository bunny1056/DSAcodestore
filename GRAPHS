Number of possible edges = n(n-1)/2
Total undirected graphs = 2^(n(n-1)/2)

# Build adjacency list
    adj = [[] for _ in range(n)]
    for u, v in edges:
        adj[u].append(v)
        adj[v].append(u)
# BFS
#User function Template for python3
from collections import deque
from typing import List  # Import List for type hints

class Solution:
    # Function to return Breadth First Search Traversal of given graph.

    def bfs(self, adj: List[List[int]]) -> List[int]:
        # code here
        V = len(adj)
        visited = [False] * V
        result = []
        
        Q = deque()
        
        Q.append(0)
        visited[0] = True
        
        while Q:
            current = Q.popleft() 
            result.append(current)
            
            for x in adj[current]:
                if not visited[x]:
                    Q.append(x)
                    visited[x] = True
        return result 
In BFS, we process nodes in First-In-First-Out (FIFO) order—the first node discovered is the first one processed.
queue.popleft() removes and returns the leftmost (oldest) element from the deque (double-ended queue), ensuring proper BFS order.
If we used queue.pop() (which removes the rightmost element), it would behave like DFS (Depth-First Search) instead! 

Normal DFS if order matters
def dfs(self, adj):
        # code here
        V = len(adj)
        st = []
        result = []
        visited = [False] * V
        st.append(0)
        while st:
            curr = st.pop()
            if not visited[curr]:
                visited[curr] = True
                result.append(curr)
                for x in reversed(adj[curr]):
                    if not visited[x]:
                        st.append(x)
        return result

Connected components(DFS)
DFS Helper:
Takes a city and marks it visited
Explores all directly connected cities (where isConnected[city][neighbor] == 1)
Recursively visits unvisited neighbors
Main Logic:
Iterate through all cities
If a city hasn't been visited, start a DFS from it
Each new DFS call represents a new province
Increment province count after each component is fully explored
3ms
def findCircleNum(self, isConnected: List[List[int]]) -> int:
        V = len(isConnected)
        visited = [False] * V
        provinces = 0

        def dfs(city):
            visited[city] = True
            for neighbour in range(V):
                if isConnected[city][neighbour] == 1 and not visited[neighbour]:
                    dfs(neighbour)
        for city in range(V):
            if not visited[city]:
                dfs(city)
                provinces += 1
        return provinces
0ms
class Solution:
    def findCircleNum(self, grid: List[List[int]]) -> int:
        if not grid: 
            return 0
        count = 0
        n = len(grid) 
        visited = [0] * n
        stack = []
        for i in range(n): 
            if (not visited[i]):
                stack.append(i)
                count += 1
                #DFS
                while stack:
                    node = stack.pop()
                    for neighbour in range(n):
                        if not visited[neighbour] and grid[node][neighbour] == 1:
                            visited[neighbour] = True
                            stack.append(neighbour)
        return count

What is Union-Find?
Union-Find has two main operations:

Union(x, y): Merges the groups containing elements x and y into a single group.
Find(x): Determines the "representative" (or root) of the group that x belongs to.
By tracking these groups, we can count how many separate clusters (provinces) exist at the end.

Key Components
Parent Array: Each element (city) has a parent pointer. Initially, every city is its own parent (a group of one).
Find with Path Compression: When finding a city’s root, we optimize by making all nodes in the path point directly to the root.
Union: Merges two groups by setting the root of one group to point to the root of the other.

class Solution:
    def findCircleNum(self, isConnected):
        n = len(isConnected)
        parent = list(range(n))  # Initial parent array
        def find(x):
            if parent[x] != x:
                parent[x] = find(parent[x])  # Path compression
            return parent[x]
        def union(x, y):
            parent[find(x)] = find(y)
        # Process connections
        for i in range(n):
            for j in range(i + 1, n):  # Avoid duplicates due to symmetry
                if isConnected[i][j] == 1:
                    union(i, j)
        # Count distinct roots
        provinces = len(set(find(i) for i in range(n)))
        return provinces

increment after for
Rotten Oranges 
from collections import deque
from typing import List

class Solution:
    def orangesRotting(self, grid: List[List[int]]) -> int:
        if not grid:
            return 0
        m = len(grid)
        n = len(grid[0])
        Q = deque()
        fresh = 0

        # since we dk starting point
        for i in range(m):
            for j in range(n):
                if grid[i][j] == 2:
                    Q.append((i,j))
                elif grid[i][j] == 1:
                    fresh += 1

        if fresh == 0:
            return 0

        directions = [(-1,0),(0,1),(1,0),(0,-1)]
        minutes = 0
        
        while Q and fresh>0:
            for _ in range(len(Q)):
                r , c = Q.popleft()
                for dr ,dc in directions:
                    nr = r + dr
                    nc = c + dc
                    if 0 <= nr < m and 0 <= nc < n and grid[nr][nc] == 1:
                        grid[nr][nc] = 2
                        fresh -= 1
                        Q.append((nr,nc))
                
            minutes +=1
        return minutes if fresh == 0 else -1

CYCLE detection 
BFS 
from typing import List
from collections import deque
class Solution:
    #Function to detect cycle in an undirected graph.
	def isCycle(self, V: int, adj: List[List[int]]) -> bool:
		#Code here
		visited = [False] * V
		parent = [-1] * V
		for i in range(V):
		    if not visited[i]:
		        Q = deque()
		        Q.append(i)
		        visited[i] = True
        		while Q:
        		    current = Q.popleft()
        		    for neighbour in adj[current]:
        		        if not visited[neighbour]:
        		            Q.append(neighbour)
        		            parent[neighbour] = current
        		            visited[neighbour] = True
        		        elif neighbour != parent[current]:
        		            return 1
	    return 0	
SAME for DFS

                
        
        


