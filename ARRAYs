def maxIndexDiff(arr):
    n = len(arr)
    if not arr or n == 0:
        return 0

    # Step 1: Preprocess - build right max array
    right_max = [0] * n
    right_max[-1] = arr[-1]
    for i in range(n - 2, -1, -1):
        right_max[i] = max(arr[i], right_max[i + 1])

    # Step 2: Traverse - initialize pointers and answer
    i = j = ans = 0
    left_min = arr[0]

    # Step 3: Two-pointer traversal
    while j < n:
        if left_min <= right_max[j]:
            ans = max(ans, j - i)
            j += 1
        else:
            i += 1
            if i < n:
                left_min = min(left_min, arr[i])

    return ans

def second_largest(arr):
    first = second = float('-inf')
    for num in arr:
        if num > first:
            second = first
            first = num
        elif num > second and num != first:
            second = num
    return second if second != float('-inf') else -1

sorted and rotated
def check(nums):
    n = len(nums)
    if n <= 1:
        return True  # An array with 0 or 1 element is trivially rotated sorted
    
    pivot = 0
    # Find the pivot where the order decreases
    for i in range(n - 1):
        if nums[i] > nums[i + 1]:
            pivot = i + 1
            break
    
    # Check if the array is already fully sorted (no pivot found)
    if pivot == 0:
        return True
    
    # Check if the remaining elements after pivot are sorted
    # and the last element is <= first element
    is_sorted = True
    for i in range(pivot, n - 1):
        if nums[i] > nums[i + 1]:
            is_sorted = False
            break
    
    return is_sorted and (nums[-1] <= nums[0])

def removeDuplicates(self, nums: List[int]) -> int:
        n = len(nums)
        if n == 0:
            return 
        k = 1
        for i in range(n-1):
            if nums[i+1] != nums[i]:
                nums[k] = nums[i + 1]
                k += 1
        return k

Left rotate
class Solution:
    def rotate(self, nums: List[int], k: int) -> None:
        n = len(nums)
        k %= n  # Handle cases where k > n

        # Two-pointer reverse function
        def reverse(left: int, right: int) -> None:
            while left < right:
                nums[left], nums[right] = nums[right], nums[left]
                left += 1
                right -= 1

        # Step 1: Reverse the entire array
        reverse(0, n - 1)

        # Step 2: Reverse the first k elements
        reverse(0, k - 1)

        # Step 3: Reverse the rest
        reverse(k, n - 1)

missing number
def missingNumber(self, nums: List[int]) -> int:
        n = len(nums)
        expected_sum = n * (n + 1) // 2
        actual_sum = sum(nums)
        return expected_sum - actual_sum
        
def longestSubarrayWithSumK(arr, n, k):
    prefix_sum = 0
    max_length = 0
    sum_index = {0: -1}  # Initialize with 0 sum at index -1
    
    for i in range(n):
        prefix_sum += arr[i]
        
        # If (prefix_sum - k) exists, we found a subarray with sum k
        if prefix_sum - k in sum_index:
            max_length = max(max_length, i - sum_index[prefix_sum - k])
        
        # Store prefix_sum only if not already present to keep earliest index
        if prefix_sum not in sum_index:
            sum_index[prefix_sum] = i
    
    return max_length

2sum
 def twoSum(self, nums: List[int], target: int) -> List[int]:
        index_map = {}  
        for i,num in enumerate(nums):
            complement = target - num
            if complement in index_map:
                return [i,index_map[complement]]
            index_map[num] = i
3sum
def threeSum(nums):
    nums.sort()
    n = len(nums)
    result = []

    for i in range(n):
        # Skip the same `nums[i]` to avoid duplicate triplets
        if i > 0 and nums[i] == nums[i - 1]:
            continue
        
        target = -nums[i]
        left = i + 1
        right = n - 1

        while left < right:
            sum_two = nums[left] + nums[right]
            if sum_two == target:
                result.append([nums[i], nums[left], nums[right]])
                left += 1
                right -= 1

                # Skip duplicates for left and right
                while left < right and nums[left] == nums[left - 1]:
                    left += 1
                while left < right and nums[right] == nums[right + 1]:
                    right -= 1
            elif sum_two < target:
                left += 1
            else:
                right -= 1

    return result

4-sum
def fourSum(nums, target):
    nums.sort()
    n = len(nums)
    result = []

    for i in range(n):
        # Skip duplicates for first number
        if i > 0 and nums[i] == nums[i - 1]:
            continue

        for j in range(i + 1, n):
            # Skip duplicates for second number
            if j > i + 1 and nums[j] == nums[j - 1]:
                continue

            left = j + 1
            right = n - 1

            while left < right:
                total = nums[i] + nums[j] + nums[left] + nums[right]
                if total == target:
                    result.append([nums[i], nums[j], nums[left], nums[right]])
                    left += 1
                    right -= 1

                    # Skip duplicates for third and fourth numbers
                    while left < right and nums[left] == nums[left - 1]:
                        left += 1
                    while left < right and nums[right] == nums[right + 1]:
                        right -= 1

                elif total < target:
                    left += 1
                else:
                    right -= 1

    return result

K-sum
def kSum(nums, target, k, start):
    res = []
    if k == 2:
        # Two-pointer base case
        left, right = start, len(nums) - 1
        while left < right:
            curr_sum = nums[left] + nums[right]
            if curr_sum == target:
                res.append([nums[left], nums[right]])
                left += 1
                right -= 1
                # Skip duplicates
                while left < right and nums[left] == nums[left - 1]:
                    left += 1
                while left < right and nums[right] == nums[right + 1]:
                    right -= 1
            elif curr_sum < target:
                left += 1
            else:
                right -= 1
    else:
        for i in range(start, len(nums) - k + 1):
            if i > start and nums[i] == nums[i - 1]:
                continue
            # Early termination
            if nums[i] * k > target:
                break
            if nums[-1] * k < target:
                break

            for subset in kSum(nums, target - nums[i], k - 1, i + 1):
                res.append([nums[i]] + subset)
    return res

def fourSum(nums, target):
    nums.sort()
    return kSum(nums, target, 4, 0)

def searchMatrix(matrix, target):
    if not matrix or not matrix[0]:
        return False

    m, n = len(matrix), len(matrix[0])
    left, right = 0, m * n - 1

    while left <= right:
        mid = (left + right) // 2
        row = mid // n
        col = mid % n
        mid_val = matrix[row][col]

        if mid_val == target:
            return True
        elif mid_val < target:
            left = mid + 1
        else:
            right = mid - 1

    return False

def myPow(x, n):
    def fast_pow(base, power):
        if power == 0:
            return 1.0
        half = fast_pow(base, power // 2)
        if power % 2 == 0:
            return half * half
        else:
            return half * half * base

    if n < 0:
        x = 1 / x
        n = -n

    return fast_pow(x, n)

sort colors/ dutch national flag
def sortColors(nums):
    low, mid, high = 0, 0, len(nums) - 1

    while mid <= high:
        if nums[mid] == 0:
            nums[low], nums[mid] = nums[mid], nums[low]
            low += 1
            mid += 1
        elif nums[mid] == 1:
            mid += 1
        else:  # nums[mid] == 2
            nums[mid], nums[high] = nums[high], nums[mid]
            high -= 1

Boyer-Moore Voting Algorithm
def majorityElement(nums):
    count = 0
    candidate = None
    for num in nums:
        if count == 0:
            candidate = num
        count += (1 if num == candidate else -1)
    return candidate

from collections import Counter
class Solution:
    def majorityElement(self, nums: List[int]) -> List[int]:
        count = Counter(nums)
        n = len(nums)
        res = []
        for num, freq in count.items():
            if freq > n/3:
                res.append(num)
        return res


Kadane's Algo
def maxSubArray(nums):
    max_sum = current_sum = nums[0]  # -2
    start = end = temp_start = 0

    for i in range(1, len(nums)):
        if nums[i] > current_sum + nums[i]:
            current_sum = nums[i]
            temp_start = i
        else:
            current_sum += nums[i]

        if current_sum > max_sum:
            max_sum = current_sum
            start = temp_start
            end = i

    return max_sum, nums[start:end+1]
OR 
def maxSubArray(nums):
    max_sum = current_sum = nums[0]
    for num in nums[1:]:
        current_sum = max(num, current_sum + num)
        max_sum = max(max_sum, current_sum)
    return max_sum


Rearrange
def rearrangeArray(self, nums: List[int]) -> List[int]:
        p, q = 0, 1
        n = len(nums)
        result = [0]*n

        for num in nums:
            if num > 0:
                result[p] = num
                p += 2
            else:
                result[q] = num
                q += 2
        return result

Leaders
def find_leaders(arr):
    n = len(arr)
    max_from_right = arr[-1]
    leaders = [max_from_right]
    
    for i in range(n - 2, -1, -1):
        if arr[i] >= max_from_right:
            max_from_right = arr[i]
            leaders.append(max_from_right)
    
    return leaders[::-1]  # Reverse to maintain the original order

Assign cookies or Maximum Matching of Players With Trainers
def find_content_children(g, s):
    g.sort()
    s.sort()
    
    i = j = 0
    content_children = 0
    
    while i < len(g) and j < len(s):
        if s[j] >= g[i]:
            content_children += 1
            i += 1
        j += 1
    
    return content_children

Max Consecutive Ones I
def findMaxConsecutiveOnes(nums):
    max_count = 0
    curr_count = 0
    for num in nums:
        if num == 1:
            curr_count += 1
            max_count = max(max_count, curr_count)
        else:
            curr_count = 0
    return max_count

Max Consecutive Ones II,III
def longestOnes(nums, k):
    left = 0
    zero_count = 0
    max_len = 0
    
    for right in range(len(nums)):
        if nums[right] == 0:
            zero_count += 1
        while zero_count > k:
            if nums[left] == 0:
                zero_count -= 1
            left += 1
        max_len = max(max_len, right - left + 1)
    
    return max_len

Longest consecutive sequence
def longestConsecutive(nums):
    if not nums:
        return 0
    
    num_set = set(nums)  # Convert array to set for O(1) lookups
    max_length = 0
    
    for num in num_set:
        # Check if num is the start of a sequence
        if num - 1 not in num_set:
            current_num = num
            current_length = 1
            
            # Count consecutive numbers
            while current_num + 1 in num_set:
                current_num += 1
                current_length += 1
            
            max_length = max(max_length, current_length)
    
    return max_length

def setZeroes(self, matrix: List[List[int]]) -> None:
    """
    Do not return anything, modify matrix in-place instead.
    """
    m, n = len(matrix), len(matrix[0])
    first_row_has_zero = any(matrix[0][j] == 0 for j in range(n))
    first_col_has_zero = any(matrix[i][0] == 0 for i in range(m))

    # Use first row and column to mark zeros
    for i in range(1, m):
        for j in range(1, n):
            if matrix[i][j] == 0:
                matrix[i][0] = 0
                matrix[0][j] = 0

    # Zero out cells based on marks in first row and column
    for i in range(1, m):
        for j in range(1, n):
            if matrix[i][0] == 0 or matrix[0][j] == 0:
                matrix[i][j] = 0

    # Zero out first row if needed
    if first_row_has_zero:
        for j in range(n):
            matrix[0][j] = 0

    # Zero out first column if needed
    if first_col_has_zero:
        for i in range(m):
            matrix[i][0] = 0

90 = transpose + reverse row
180 = reverse row + reverse column
270 = transpose + reverse col

def rotate(matrix):
    matrix[:] = [list(row) for row in zip(*matrix[::-1])]
def rotate(self, m: List[List[int]]) -> None:
        for i in range(len(m)):
            for j in range(i+1,len(m)):
                a=m[i][j]
                m[i][j]=m[j][i]
                m[j][i]=a
        for i in range(len(m)):
            for j in range(len(m)//2):
                a=m[i][j]
                m[i][j]=m[i][len(m)-1-j]
                m[i][len(m)-1-j]=a

def reversePairs(nums):
    def merge_sort(start, end):
        if start >= end:
            return 0
        mid = (start + end) // 2
        count = merge_sort(start, mid) + merge_sort(mid + 1, end)

        # Count reverse pairs
        j = mid + 1
        for i in range(start, mid + 1):
            while j <= end and nums[i] > 2 * nums[j]:
                j += 1
            count += j - (mid + 1)

        # Merge step
        temp = []
        left, right = start, mid + 1
        while left <= mid and right <= end:
            if nums[left] <= nums[right]:
                temp.append(nums[left])
                left += 1
            else:
                temp.append(nums[right])
                right += 1
        while left <= mid:
            temp.append(nums[left])
            left += 1
        while right <= end:
            temp.append(nums[right])
            right += 1

        # Copy sorted part back

class Solution:
    def nextPermutation(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        # 5, 2, 6, 1, 2

        pivot = 0

        for i in range(len(nums) - 1, 0, -1):
            if nums[i - 1] < nums[i]:
                pivot = i
                break

        if pivot == 0:
            nums[::] = nums[::-1]
            return

        swap = len(nums) - 1

        while nums[pivot - 1] >= nums[swap]:
            swap -= 1

        nums[pivot - 1], nums[swap] = nums[swap], nums[pivot - 1]
        nums[pivot:] = reversed(nums[pivot:])

        return

        
        nums[start:end+1] = temp
        return count

    return merge_sort(0, len(nums) - 1)

from collections import Counter

def rearrange_blocks(blocks):
    # Step 1: Flatten the list and count number of houses per block
    flat_list = []
    block_sizes = []

    for block in blocks:
        flat_list.extend(block)
        block_sizes.append(len(block))

    # Step 2: Sort the flat list
    flat_list.sort()
    
    # Step 3: Distribute sorted values into blocks with unique and sorted values
    new_blocks = [[] for _ in block_sizes]
    used = Counter()

    i = 0  # Index for values in flat_list
    for round in range(max(block_sizes)):  # Go round-robin
        for b in range(len(block_sizes)):
            if len(new_blocks[b]) < block_sizes[b]:
                # Pick the next unused unique value
                while i < len(flat_list) and flat_list[i] in new_blocks[b]:
                    i += 1
                if i < len(flat_list):
                    new_blocks[b].append(flat_list[i])
                    i += 1

    # Sort each block (should be sorted already, but just in case)
    for block in new_blocks:
        block.sort()

    return new_blocks

def findDuplicateAndMissing(arr):
    n = len(arr)
    
    sum_actual = sum(arr)
    sum_sq_actual = sum(x * x for x in arr)
    
    sum_expected = n * (n + 1) // 2
    sum_sq_expected = n * (n + 1) * (2 * n + 1) // 6

    S1 = sum_actual - sum_expected          # A - B
    S2 = sum_sq_actual - sum_sq_expected    # A^2 - B^2 = (A - B)(A + B)

    # A + B = S2 / S1
    A_plus_B = S2 // S1
    A = (S1 + A_plus_B) // 2
    B = A - S1

    return [A, B]

Trap_water
def trap(height):
    if not height:
        return 0
    
    n = len(height)
    left_max = [0] * n
    right_max = [0] * n
    
    # Compute the left maximum for each position
    left_max[0] = height[0]
    for i in range(1, n):
        left_max[i] = max(left_max[i-1], height[i])
    
    # Compute the right maximum for each position
    right_max[n-1] = height[n-1]
    for i in range(n-2, -1, -1):
        right_max[i] = max(right_max[i+1], height[i])
    
    # Calculate the trapped water
    trapped_water = 0
    for i in range(n):
        trapped_water += min(left_max[i], right_max[i]) - height[i]
    
    return trapped_water
