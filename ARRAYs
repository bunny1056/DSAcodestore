Maximum index
# Python program to find the maximum
# j - i such that arr[i] <= arr[j]

# Function to find the maximum
# j - i such that arr[i] <= arr[j]
def maxIndexDiff(arr):
    n = len(arr)
    rMax = [0] * n
    i, j = 0, 0
    lMin = arr[0]
    
    # rMax[i] stores the maximum value
    # in the range [i, n-1]
    rMax[n - 1] = arr[n - 1]
    for i in range(n - 2, -1, -1):
        rMax[i] = max(rMax[i + 1], arr[i])
    
    i, j, ans = 0, 0, 0
    
    while i < n and j < n:
        
        # Compare with answer and increment j.
        if lMin <= rMax[j]:
            ans = max(ans, j - i)
            j += 1
        
        # Else, increment i.
        else:
            i += 1
            if i + 1 < n:
                lMin = min(lMin, arr[i])
    
    return ans

def second_largest(arr):
    first = second = float('-inf')
    for num in arr:
        if num > first:
            second = first
            first = num
        elif num > second and num != first:
            second = num
    return second if second != float('-inf') else -1

sorted and rotated
def check(nums):
    n = len(nums)
    if n <= 1:
        return True  # An array with 0 or 1 element is trivially rotated sorted
    
    pivot = 0
    # Find the pivot where the order decreases
    for i in range(n - 1):
        if nums[i] > nums[i + 1]:
            pivot = i + 1
            break
    
    # Check if the array is already fully sorted (no pivot found)
    if pivot == 0:
        return True
    
    # Check if the remaining elements after pivot are sorted
    # and the last element is <= first element
    is_sorted = True
    for i in range(pivot, n - 1):
        if nums[i] > nums[i + 1]:
            is_sorted = False
            break
    
    return is_sorted and (nums[-1] <= nums[0])

def removeDuplicates(self, nums: List[int]) -> int:
        n = len(nums)
        if n == 0:
            return 
        k = 1
        for i in range(n-1):
            if nums[i+1] != nums[i]:
                nums[k] = nums[i + 1]
                k += 1
        return k

Left rotate
class Solution:
    def rotate(self, nums: List[int], k: int) -> None:
        n = len(nums)
        k %= n  # Handle cases where k > n

        # Two-pointer reverse function
        def reverse(left: int, right: int) -> None:
            while left < right:
                nums[left], nums[right] = nums[right], nums[left]
                left += 1
                right -= 1

        # Step 1: Reverse the entire array
        reverse(0, n - 1)

        # Step 2: Reverse the first k elements
        reverse(0, k - 1)

        # Step 3: Reverse the rest
        reverse(k, n - 1)

missing number
def missingNumber(self, nums: List[int]) -> int:
        n = len(nums)
        expected_sum = n * (n + 1) // 2
        actual_sum = sum(nums)
        return expected_sum - actual_sum
        
def longestSubarrayWithSumK(arr, n, k):
    prefix_sum = 0
    max_length = 0
    sum_index = {0: -1}  # Initialize with 0 sum at index -1
    
    for i in range(n):
        prefix_sum += arr[i]
        
        # If (prefix_sum - k) exists, we found a subarray with sum k
        if prefix_sum - k in sum_index:
            max_length = max(max_length, i - sum_index[prefix_sum - k])
        
        # Store prefix_sum only if not already present to keep earliest index
        if prefix_sum not in sum_index:
            sum_index[prefix_sum] = i
    
    return max_length
