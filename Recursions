def print_n_to_1(n):
    if n == 0:  # Base case
        return
    print(n, end=' ')  # Print current number first
    print_n_to_1(n - 1)  # Then recurse with n-1
def print_1_to_n(n):
    if n == 0:  # Base case
        return
      # Print current number first
    print_n_to_1(n - 1)  # Then recurse with n-1
    print(n, end=' ')

def backtrack(path, current):
    if current == target:
        results.append(path[:])
        return
    for neighbor in graph[current]:
        backtrack(path + [neighbor], neighbor)

