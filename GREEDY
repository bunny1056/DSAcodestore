



Minimum platforms
def findPlatform(arr, dep, n):
    arr.sort()
    dep.sort()
    
    platforms_needed = 1
    max_platforms = 1
    i = 1
    j = 0
    
    while i < n and j < n:
        if arr[i] <= dep[j]:
            platforms_needed += 1
            i += 1
            if platforms_needed > max_platforms:
                max_platforms = platforms_needed
        else:
            platforms_needed -= 1
            j += 1
    
    return max_platforms

CANDY
def candy(self, ratings: List[int]) -> int:
        candies = [1] * len(ratings)
        n = len(ratings)

        for i in range(1,n):
            if ratings[i] > ratings[i-1]:
                candies[i] = candies[i-1] + 1

        for i in range(n-2,-1,-1):
            if ratings[i] > ratings[i+1]:
                candies[i] = max(candies[i],candies[i+1]+1)

        return sum(candies) 
https://www.geeksforgeeks.org/cpu-scheduling-in-operating-systems/

insert interval
from typing import List

def insert(intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:
    result = []
    i = 0
    n = len(intervals)

    # 1. Add intervals before newInterval
    while i < n and intervals[i][1] < newInterval[0]:
        result.append(intervals[i])
        i += 1

    # 2. Merge overlapping intervals
    while i < n and intervals[i][0] <= newInterval[1]:
        newInterval[0] = min(newInterval[0], intervals[i][0])
        newInterval[1] = max(newInterval[1], intervals[i][1])
        i += 1
    result.append(newInterval)

    # 3. Add remaining intervals
    while i < n:
        result.append(intervals[i])
        i += 1

    return result

Merge intervals
from typing import List

def merge(self, intervals: List[List[int]]) -> List[List[int]]:
    if not intervals:
        return []

    # First, sort the intervals by starting time
    intervals.sort(key=lambda x: x[0])
    res = [intervals[0]]

    for i in range(1, len(intervals)):
        last = res[-1]
        current = intervals[i]
        
        # If they overlap, merge
        if last[1] >= current[0]:
            last[1] = max(last[1], current[1])
        else:
            res.append(current)

    return res

Non overlapping intervals
from typing import List

def eraseOverlapIntervals(intervals: List[List[int]]) -> int:
    # Step 1: Sort by end time
    intervals.sort(key=lambda x: x[1])

    count = 0
    prev_end = float('-inf')

    for start, end in intervals:
        if start >= prev_end:
            # No overlap, include this interval
            prev_end = end
        else:
            # Overlap, we need to remove this one
            count += 1

    return count

job sequencing problm
def job_sequencing(deadline, profit):
    n = len(deadline)
    jobs = list(zip(deadline, profit))
    # Sort jobs by profit in descending order
    jobs.sort(key=lambda x: -x[1])
    
    max_deadline = max(deadline)
    slots = [False] * (max_deadline + 1)  # 1-based indexing
    
    count = 0
    total_profit = 0
    
    for d, p in jobs:
        # Find the latest available slot before deadline d
        for i in range(d, 0, -1):
            if not slots[i]:
                slots[i] = True
                count += 1
                total_profit += p
                break
    
    return [count, total_profit]

def findOrder(height, infront):
    # Write your code here.
    pass
    people = list(zip(height, infront))
    # Sort people in descending order of height, and ascending order of infront (though heights are unique)
    people.sort(key=lambda x: (-x[0], x[1]))
    
    result = []
    for p in people:
        h, k = p
        result.insert(k, h)
    
    return result
Sort by Height in Descending Order: First, we sort all people in descending order of their height. For people of the same height, we sort them in ascending order of their "infront" values (though the problem states all heights are unique, so this might not be necessary here).

Insert into the Result List: For each person in the sorted list, we insert them into the result list at the position specified by their "infront" value. This works because all taller people have already been placed, and inserting at the "infront" position ensures that exactly that many taller people are in front of them.

def longestZigZag(arr):
    n = len(arr)
    if n < 2:
        return n

    count = 1  # At least one element is part of the subsequence
    prev_diff = 0

    for i in range(1, n):
        diff = arr[i] - arr[i - 1]
        if (diff > 0 and prev_diff <= 0) or (diff < 0 and prev_diff >= 0):
            count += 1
            prev_diff = diff

    return count

class Solution:
    def findLongestChain(self, pairs: List[List[int]]) -> int:
        pairs.sort(key=lambda x: x[1])
        cur_end = float('-inf')
        count = 0
        for s, e in pairs:
            if s > cur_end:
                count += 1
                cur_end = e
        return count
