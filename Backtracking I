Rat in a maze
def findPaths(mat, n):
    def is_valid(r, c):
        return 0 <= r < n and 0 <= c < n and mat[r][c] == 1 and not visited[r][c]

    def backtrack(r, c, path):
        if r == n - 1 and c == n - 1:
            result.append(path)
            return

        for dir_idx in range(4):
            dr, dc = dirs[dir_idx]
            nr, nc = r + dr, c + dc
            move = dir_letters[dir_idx]

            if is_valid(nr, nc):
                visited[nr][nc] = True
                backtrack(nr, nc, path + move)
                visited[nr][nc] = False  # backtrack

    if mat[0][0] == 0 or mat[n-1][n-1] == 0:
        return []

    result = []
    visited = [[False] * n for _ in range(n)]
    dirs = [(1, 0), (0, -1), (0, 1), (-1, 0)]  # D, L, R, U
    dir_letters = ['D', 'L', 'R', 'U']

    visited[0][0] = True
    backtrack(0, 0, "")
    return sorted(result)

def combinationSum(self, arr, target):
    def backtrack(start, path, total):
        if total == target:
            res.append(path[:])
            return
        if total > target:
            return
        
        for i in range(start, len(arr)):
            path.append(arr[i])
            backtrack(i, path, total + arr[i])  # reuse allowed if not allowed use i+1
            path.pop()

    res = []
    arr = sorted(set(arr))  # optional: remove duplicates and sort
    backtrack(0, [], 0)
    return res

CrossWord Puzzle

1. Preprocess the Grid to Identify All Valid Slots
A slot is a contiguous sequence of - cells where a word can be placed.
We extract:
Horizontal slots: scan each row for contiguous -.
Vertical slots: scan each column for contiguous -.
Store each slot as:
(start_row, start_col, direction, length)

2. Backtracking Algorithm
We try placing each unused word into each slot (matching length), then recurse.
Key Steps:
For a given slot, try every unused word of matching length.
If the word can be placed (i.e., cells are either - or already contain the same character), place it.
Recurse to the next slot.
If recursion fails, backtrack by undoing the placement and trying the next possibility.
If all slots are filled and all words are used â†’ Success.

class Solution:
    def solveNQueensPerm(self, n):
        def backtrack(col, path):
            if col == n:
                res.append(path[:])
                return
            for row in range(1, n+1):  # 1-based row index
                if row in used_rows:
                    continue
                valid = True
                for c, r in enumerate(path):  # previous queens
                    if abs(r - row) == abs(c - col):
                        valid = False
                        break
                if valid:
                    used_rows.add(row)
                    path.append(row)
                    backtrack(col + 1, path)
                    path.pop()
                    used_rows.remove(row)

        res = []
        used_rows = set()
        backtrack(0, [])
        return res

def graphColoring(self, v, edges, m):
        # code here
        adj = defaultdict(list)
        for u, b in edges:
            adj[u].append(b)
            adj[b].append(u)
        
        def is_safe(node,color,col):
            for nei in adj[node]:
                if col[nei] == color:
                    return False
            return True
        
        def backtrack(node,col):
            if node == v:
                return True
            
            for color in range(1,m+1):
                if is_safe(node,color,col):
                    col[node] = color
                
                    if backtrack(node+1,col):
                        return True
                
                col[node] = 0
            return False
        
        col = [0] * v
        return backtrack(0,col)

# Python Code for Knights Tour Problem
# Using Recursion + Backtracking

def isSafe(x, y, n, board):
    return x >= 0 and y >= 0 and x < n and y < n and board[x][y] == -1

def knightTourUtil(x, y, step, n, board, dx, dy):
    
    # If all squares are visited
    if step == n * n:
        return True

    # Try all 8 possible knight moves
    for i in range(8):
        nx = x + dx[i]
        ny = y + dy[i]

        if isSafe(nx, ny, n, board):
            board[nx][ny] = step

            if knightTourUtil(nx, ny, step + 1, n, board, dx, dy):
                return True

            # Backtrack
            board[nx][ny] = -1

    return False

def knightTour(n):

    board = [[-1 for _ in range(n)] for _ in range(n)]

    # 8 directions of knight moves
    dx = [2, 1, -1, -2, -2, -1, 1, 2]
    dy = [1, 2, 2, 1, -1, -2, -2, -1]

    # Start from top-left corner
    board[0][0] = 0

    if knightTourUtil(0, 0, 1, n, board, dx, dy):
        return board

    return [[-1]]
