Activity Selection/ Interval Scheduling / maxlength chain pairs(sort by end time)
Goal: Maximize count of non-overlapping intervals
Intuition: Pick job that finishes earliest

def activitySelection(start, finish):
    n = len(start)
    intervals = list(zip(start, finish))
    intervals.sort(key=lambda x: x[1])

    count = 1
    end = intervals[0][1]

    for i in range(1, n):
        if intervals[i][0] >= end:
            count += 1
            end = intervals[i][1]

    return count

def minSum(self, arr, n):
        # Your code goes here
        if n == 1:
            return arr[0]
        heapq.heapify(arr)
        num1, num2 = [], []
    
        while arr:
            num1.append(str(heapq.heappop(arr)))
            if arr:
                num2.append(str(heapq.heappop(arr)))
    
        return int("".join(num1)) + int("".join(num2))

def minPartition(self, N):
        # code here
        coins = [1,2,5,10,20,50,100,200,500,2000]
        coins.sort(reverse=True)
        res = []
        
        for coin in coins:
            while N >= coin:
                N -= coin
                res.append(coin)
            if N == 0:
                break
        return res

def minCost(coin, n, k): 
    coin.sort()
    coins_needed = math.ceil(1.0 * n //
                            (k + 1));

    ans = 0
    for i in range(coins_needed - 1 + 1): 
        ans += coin[i]
    return ans

def maxLevel(boxes, n):
    # Sort objects in increasing order of width
    boxes.sort()
    ans = 1 
    prev_width = boxes[0]
    prev_count = 1
    curr_count = 0
    curr_width = 0
    for i in range(1, n):
        curr_width += boxes[i]
        curr_count += 1
        if (curr_width > prev_width and curr_count > prev_count):
            prev_width = curr_width
            prev_count = curr_count
            curr_count = 0
            curr_width = 0
            ans += 1
    return ans

Job Scheduling
def jobSequencing(self, deadline, profit):
        # code here
        jobs = list(zip(deadline,profit))
        jobs.sort()
        
        pq = []
        ans = [0,0]
        
        for job in jobs:
            if job[0] > len(pq):
                heapq.heappush(pq,job[1])
            elif pq and pq[0] < job[1]:
                heapq.heappushpop(pq,job[1])
        
        while pq:
            ans[1] += heapq.heappop(pq)
            ans[0] += 1
        
        return ans

def egyptian_fraction(a, b):
    result = []
    while a != 0:
        # Find the ceiling of b/a
        x = (b + a - 1) // a
        result.append(x)
        # Update a and b: a/b - 1/x = (a*x - b) / (b*x)
        a = a * x - b
        b = b * x

    return result

def smallestNumber(s, d):
    if s == 0:
        return "0" if d == 1 else "-1"
    if s > 9 * d:
        return "-1"
    res = []
    remaining_sum = s
    for i in range(d):
        if i == 0:
            # First digit can't be zero
            min_digit = 1
        else:
            min_digit = 0
        # The remaining digits (d - i - 1) can contribute at most 9 each
        remaining_digits = d - i - 1
        for digit in range(min_digit, 10):
            remaining_after = remaining_sum - digit
            if 0 <= remaining_after <= 9 * remaining_digits:
                res.append(str(digit))
                remaining_sum = remaining_after
                break
    return ''.join(res)
