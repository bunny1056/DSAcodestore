Activity Selection/ Interval Scheduling
Goal: Maximize count of non-overlapping intervals
Intuition: Pick job that finishes earliest

def activitySelection(start, finish):
    n = len(start)
    intervals = list(zip(start, finish))
    intervals.sort(key=lambda x: x[1])

    count = 1
    end = intervals[0][1]

    for i in range(1, n):
        if intervals[i][0] >= end:
            count += 1
            end = intervals[i][1]

    return count

def minSum(self, arr, n):
        # Your code goes here
        if n == 1:
            return arr[0]
        heapq.heapify(arr)
        num1, num2 = [], []
    
        while arr:
            num1.append(str(heapq.heappop(arr)))
            if arr:
                num2.append(str(heapq.heappop(arr)))
    
        return int("".join(num1)) + int("".join(num2))

def minPartition(self, N):
        # code here
        coins = [1,2,5,10,20,50,100,200,500,2000]
        coins.sort(reverse=True)
        res = []
        
        for coin in coins:
            while N >= coin:
                N -= coin
                res.append(coin)
            if N == 0:
                break
        return res

def minCost(coin, n, k): 
    coin.sort()
    coins_needed = math.ceil(1.0 * n //
                            (k + 1));

    ans = 0
    for i in range(coins_needed - 1 + 1): 
        ans += coin[i]
    return ans

Job Scheduling
def jobSequencing(self, deadline, profit):
        # code here
        jobs = list(zip(deadline,profit))
        jobs.sort()
        
        pq = []
        ans = [0,0]
        
        for job in jobs:
            if job[0] > len(pq):
                heapq.heappush(pq,job[1])
            elif pq and pq[0] < job[1]:
                heapq.heappushpop(pq,job[1])
        
        while pq:
            ans[1] += heapq.heappop(pq)
            ans[0] += 1
        
        return ans
