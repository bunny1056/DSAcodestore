Activity Selection/ Interval Scheduling / maxlength chain pairs(sort by end time)
Goal: Maximize count of non-overlapping intervals
Intuition: Pick job that finishes earliest

def activitySelection(start, finish):
    n = len(start)
    intervals = list(zip(start, finish))
    intervals.sort(key=lambda x: x[1])

    count = 1
    end = intervals[0][1]

    for i in range(1, n):
        if intervals[i][0] >= end:
            count += 1
            end = intervals[i][1]

    return count

def minSum(self, arr, n):
        # Your code goes here
        if n == 1:
            return arr[0]
        heapq.heapify(arr)
        num1, num2 = [], []
    
        while arr:
            num1.append(str(heapq.heappop(arr)))
            if arr:
                num2.append(str(heapq.heappop(arr)))
    
        return int("".join(num1)) + int("".join(num2))

def minPartition(self, N):
        # code here
        coins = [1,2,5,10,20,50,100,200,500,2000]
        coins.sort(reverse=True)
        res = []
        
        for coin in coins:
            while N >= coin:
                N -= coin
                res.append(coin)
            if N == 0:
                break
        return res

def minCost(coin, n, k): 
    coin.sort()
    coins_needed = math.ceil(1.0 * n //
                            (k + 1));

    ans = 0
    for i in range(coins_needed - 1 + 1): 
        ans += coin[i]
    return ans

Assign Cookies
def findContentChildren(g, s):
    g.sort()
    s.sort()
    
    i = j = 0  # i: child index, j: cookie index
    while i < len(g) and j < len(s):
        if s[j] >= g[i]:
            i += 1  # assign cookie to child
        j += 1  # move to next cookie
    
    return i  # number of content children

def maxLevel(boxes, n):
    # Sort objects in increasing order of width
    boxes.sort()
    ans = 1 
    prev_width = boxes[0]
    prev_count = 1
    curr_count = 0
    curr_width = 0
    for i in range(1, n):
        curr_width += boxes[i]
        curr_count += 1
        if (curr_width > prev_width and curr_count > prev_count):
            prev_width = curr_width
            prev_count = curr_count
            curr_count = 0
            curr_width = 0
            ans += 1
    return ans

Job Scheduling
def jobSequencing(self, deadline, profit):
        # code here
        jobs = list(zip(deadline,profit))
        jobs.sort()
        
        pq = []
        ans = [0,0]
        
        for job in jobs:
            if job[0] > len(pq):
                heapq.heappush(pq,job[1])
            elif pq and pq[0] < job[1]:
                heapq.heappushpop(pq,job[1])
        
        while pq:
            ans[1] += heapq.heappop(pq)
            ans[0] += 1
        
        return ans

def egyptian_fraction(a, b):
    result = []
    while a != 0:
        # Find the ceiling of b/a
        x = (b + a - 1) // a
        result.append(x)
        # Update a and b: a/b - 1/x = (a*x - b) / (b*x)
        a = a * x - b
        b = b * x

    return result

def smallestNumber(s, d):
    if s == 0:
        return "0" if d == 1 else "-1"
    if s > 9 * d:
        return "-1"
    res = []
    remaining_sum = s
    for i in range(d):
        if i == 0:
            # First digit can't be zero
            min_digit = 1
        else:
            min_digit = 0
        # The remaining digits (d - i - 1) can contribute at most 9 each
        remaining_digits = d - i - 1
        for digit in range(min_digit, 10):
            remaining_after = remaining_sum - digit
            if 0 <= remaining_after <= 9 * remaining_digits:
                res.append(str(digit))
                remaining_sum = remaining_after
                break
    return ''.join(res)

CHOCOLA problem min cost to cut in 1X1 squares (same as merge sort)
def min_cost_to_cut_chocolate(horizontal_cuts, vertical_cuts):
    # Sort in descending order
    horizontal_cuts.sort(reverse=True)
    vertical_cuts.sort(reverse=True)

    h_segments = 1  # initially one vertical segment
    v_segments = 1  # initially one horizontal segment

    i = j = 0
    cost = 0

    while i < len(horizontal_cuts) and j < len(vertical_cuts):
        if horizontal_cuts[i] > vertical_cuts[j]:
            cost += horizontal_cuts[i] * v_segments
            h_segments += 1
            i += 1
        else:
            cost += vertical_cuts[j] * h_segments
            v_segments += 1
            j += 1

    # Process remaining horizontal cuts
    while i < len(horizontal_cuts):
        cost += horizontal_cuts[i] * v_segments
        i += 1

    # Process remaining vertical cuts
    while j < len(vertical_cuts):
        cost += vertical_cuts[j] * h_segments
        j += 1

    return cost

from collections import deque, defaultdict

def minEdgeReversals(N, M, edges, src, dst):
    graph = defaultdict(list)

    # Build the modified graph
    for u, v in edges:
        graph[u].append((v, 0))  # original direction, no cost
        graph[v].append((u, 1))  # reversed edge, cost = 1

    # 0-1 BFS
    dq = deque()
    dq.append((src, 0))  # (node, cost)
    visited = [False] * (N + 1)

    while dq:
        node, cost = dq.popleft()

        if node == dst:
            return cost

        if visited[node]:
            continue
        visited[node] = True

        for nei, wt in graph[node]:
            if not visited[nei]:
                if wt == 0:
                    dq.appendleft((nei, cost))  # 0-cost edge
                else:
                    dq.append((nei, cost + 1))  # 1-cost edge

    return -1  # if dst is unreachable

def minCashFlow(graph):
    N = len(graph)
    
    # Step 1: Compute net balance
    amount = [0] * N
    for i in range(N):
        for j in range(N):
            amount[i] += graph[j][i] - graph[i][j]

    # Only consider non-zero balances
    def get_max_credit_debit():
        max_credit = max([(i, amt) for i, amt in enumerate(amount)], key=lambda x: x[1])
        max_debit = min([(i, amt) for i, amt in enumerate(amount)], key=lambda x: x[1])
        return max_credit[0], max_debit[0]

    res = []

    def settle():
        mxC, mxD = get_max_credit_debit()

        if amount[mxC] == 0 and amount[mxD] == 0:
            return

        min_amt = min(amount[mxC], -amount[mxD])
        amount[mxC] -= min_amt
        amount[mxD] += min_amt
        res.append((mxD, mxC, min_amt))

        settle()

    settle()

    return res
